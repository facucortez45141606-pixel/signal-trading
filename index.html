<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Analizador de Velas desde Imagen — Demo</title>
<style>
  body { font-family: Inter, system-ui, -apple-system, Arial; max-width: 1100px; margin: 16px auto; padding: 12px; color:#0b1220; }
  h1 { margin: 6px 0 14px; }
  .row { display:flex; gap:12px; align-items:flex-start; }
  .col { flex:1; min-width:280px; }
  .panel { background:#f7f9fc; padding:12px; border-radius:8px; box-shadow: 0 1px 6px rgba(10,20,40,0.04);}
  input[type=file] { display:block; margin:8px 0; }
  button { padding:8px 12px; border-radius:6px; background:#0f6fff;color:#fff;border:0; cursor:pointer;}
  button:disabled { opacity:0.6; cursor:not-allowed; }
  canvas { border:1px solid #ddd; display:block; max-width:100%; background:white; }
  pre { background:#051223; color:#dbefff; padding:10px; border-radius:6px; overflow:auto; max-height:250px;}
  small { color:#555; }
  .badge { display:inline-block; padding:6px 10px; border-radius:999px; background:#e6eefc; color:#083b8a; font-weight:600;}
  .outcome { font-size:1.35rem; font-weight:700; margin-top:10px; }
  .green { color:#0f8a3b; } .red { color:#b32424; } .gray { color:#666; }
  .meter { height:14px; background:#e6eefc; border-radius:999px; overflow:hidden; }
  .meter > i { display:block; height:100%; background:linear-gradient(90deg,#0f8a3b,#0f6fff); width:0%; }
  .section-title { font-weight:700; margin:8px 0; }
  details { margin-top:8px; }
  .note { font-size:0.9rem; color:#444; }
</style>
</head>
<body>
  <h1>Analizador de Velas desde Imagen (Demo para GitHub Pages)</h1>
  <div class="row">
    <div class="col panel">
      <div class="section-title">1) Subí la imagen del gráfico</div>
      <input id="imgfile" type="file" accept="image/*"/>
      <small>Preferible: fondo claro, velas verdes/rojas, eje Y visible. Mejor resolución = mejor extracción.</small>
      <div style="margin-top:8px;">
        <label><input id="assumeColors" type="checkbox" checked/> Asumir velas verdes (alcistas) y rojas (bajistas)</label><br>
        <label><input id="autoCrop" type="checkbox" checked/> Intentar auto-detectar zona de gráfico (barras y ejes)</label>
      </div>
      <div style="margin-top:12px;">
        <button id="startBtn" disabled>Analizar imagen (20s)</button>
        <button id="clearBtn">Limpiar</button>
      </div>
      <div style="margin-top:12px;">
        <canvas id="canvas" width=800 height=400></canvas>
      </div>
      <div style="margin-top:10px">
        <small class="note">Opcional: si preferís mayor precisión, usá la opción de "traer datos" (requiere backend/keys). Aquí el flujo es 100% cliente.</small>
      </div>
    </div>

    <div class="col panel">
      <div class="section-title">2) Resultado del análisis</div>
      <div id="status">Estado: <span class="badge">Esperando imagen</span></div>

      <div id="countdown" style="margin-top:8px;"></div>

      <div id="resultBox" style="margin-top:12px; display:none;">
        <div class="outcome" id="recommendation">RECOMENDACIÓN: <span id="recText" class="gray">—</span></div>
        <div style="margin-top:8px;">
          Probabilidad estimada: <strong id="probText">0%</strong>
          <div class="meter" aria-hidden><i id="meterBar" style="width:0%"></i></div>
        </div>
        <div style="margin-top:10px;">
          <div><strong>Factores que influyeron (resumen):</strong></div>
          <ul id="factors"></ul>
        </div>

        <details style="margin-top:10px;">
          <summary>Explicación técnica completa (por qué la decisión)</summary>
          <div id="explanation" style="padding:8px 0;"></div>
        </details>

        <details style="margin-top:10px;">
          <summary>Datos extraídos (OHLC aproximado por vela)</summary>
          <pre id="dataOut"></pre>
        </details>
      </div>
    </div>
  </div>

  <hr/>

  <div class="panel">
    <div class="section-title">Notas sobre metodología y limitaciones</div>
    <p class="note">Esta herramienta realiza una <strong>extracción por píxeles</strong> para inferir precios desde la imagen. Es un enfoque heurístico que funciona en imágenes con colores/formatos consistentes. Para trading real, usá datos OHLC/tick desde la API de tu broker y backtesting con tick-level data.</p>
    <p class="note">Basamos la decisión en reglas técnicas clásicas: medias móviles (tendencia), RSI (momentum), ATR (volatilidad), patrones de velas (confirmación). Referencias teóricas: Steve Nison (candlesticks), John J. Murphy (análisis técnico).</p>
  </div>

<script>
/*
  Demo heurístico:
  - Carga imagen en canvas
  - Intenta localizar área de gráfico (si autoCrop habilitado)
  - Busca líneas verticales/segmentos de color que representen velas (verde/red/black)
  - Construye una serie de velas (OHLC aproximado) normalizando por píxeles Y
  - Calcula indicadores: EMA(8), EMA(21), RSI(14), ATR(14)
  - Combina señales y produce una probabilidad (score 0-100)
  - 20s "análisis" (visual countdown) antes de resultado final
*/

/* ---------- Utility indicators ---------- */
function ema(arr, period){
  const out = new Array(arr.length).fill(null);
  const k = 2/(period+1);
  // need first SMA for seed
  let seed = 0, seeded=false;
  for(let i=0;i<arr.length;i++){
    const v = arr[i];
    if(v==null) { continue; }
    if(!seeded){
      // accumulate until period
      seed += v;
      if(i === period-1){
        seed = seed/period;
        out[i] = seed;
        seeded = true;
      }
      continue;
    } else {
      const prev = out[i-1] ?? out.slice(0,i).reverse().find(x=>x!=null) ?? seed;
      out[i] = v*k + prev*(1-k);
    }
  }
  return out;
}
function rsi(close, period=14){
  const out = new Array(close.length).fill(null);
  let gains=0, losses=0;
  for(let i=1;i<close.length;i++){
    const diff = close[i] - close[i-1];
    if(i<=period){
      if(diff>0) gains += diff; else losses += Math.abs(diff);
      if(i===period){
        const avgGain = gains/period;
        const avgLoss = Math.max(1e-9, losses/period);
        const rs = avgGain/avgLoss;
        out[i] = 100 - (100/(1+rs));
        gains = avgGain; losses = avgLoss;
      }
      continue;
    }
    const up = Math.max(0, diff), down = Math.max(0, -diff);
    gains = (gains*(period-1) + up)/period;
    losses = (losses*(period-1) + down)/period;
    const rs = gains/Math.max(1e-9,losses);
    out[i] = 100 - (100/(1+rs));
  }
  return out;
}
function atr(high, low, close, period=14){
  const out = new Array(close.length).fill(null);
  const tr = [];
  for(let i=0;i<close.length;i++){
    if(i===0){ tr[i] = high[i]-low[i]; continue; }
    tr[i] = Math.max(high[i]-low[i], Math.abs(high[i]-close[i-1]), Math.abs(low[i]-close[i-1]));
  }
  // Wilder's smoothing
  let sum = 0;
  for(let i=1;i<=period;i++){ sum += tr[i] || 0; }
  out[period] = sum/period;
  for(let i=period+1;i<tr.length;i++){
    out[i] = ((out[i-1] * (period-1)) + tr[i]) / period;
  }
  return out;
}

/* ---------- Image processing heuristics ---------- */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let loadedImage = null;
let extractedCandles = null;

document.getElementById('imgfile').addEventListener('change', async (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = ()=>{
    // scale to canvas while keeping aspect
    const maxW = 1000, maxH = 600;
    let w = img.width, h = img.height;
    const ratio = Math.min(maxW/w, maxH/h, 1);
    canvas.width = Math.round(w * ratio);
    canvas.height = Math.round(h * ratio);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img, 0,0, canvas.width, canvas.height);
    loadedImage = img;
    document.getElementById('startBtn').disabled = false;
    document.getElementById('status').innerHTML = 'Estado: <span class="badge">Imagen cargada</span>';
  };
  img.onerror = ()=> alert('No se pudo cargar la imagen.');
  img.src = url;
});

document.getElementById('clearBtn').addEventListener('click', ()=>{
  ctx.clearRect(0,0,canvas.width,canvas.height);
  document.getElementById('imgfile').value = '';
  document.getElementById('startBtn').disabled = true;
  document.getElementById('status').innerHTML = 'Estado: <span class="badge">Esperando imagen</span>';
  document.getElementById('resultBox').style.display='none';
  extractedCandles = null;
});

/* Heuristic: detect vertical candle "strokes" scanning columns for colored pixels.
   Works best when candlesticks are colored (green/red) on light background.
*/
function extractCandlesFromCanvas(opts){
  const w = canvas.width, h = canvas.height;
  const im = ctx.getImageData(0,0,w,h);
  const data = im.data;
  function getPixel(x,y){
    const i = (y*w + x)*4;
    return {r:data[i], g:data[i+1], b:data[i+2], a:data[i+3]};
  }
  // search for probable plot area: find dense pixel area not white
  let minY = h, maxY = 0;
  let minX = w, maxX = 0;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x+=4){
      const p = getPixel(x,y);
      // consider "non-background" as not near white
      if(p.r<245 || p.g<245 || p.b<245){
        if(y<minY) minY = y;
        if(y>maxY) maxY = y;
        if(x<minX) minX = x;
        if(x>maxX) maxX = x;
      }
    }
  }
  if(opts.autoCrop){
    if(minY >= maxY || minX >= maxX){
      // fallback to whole canvas
      minX=0; minY=0; maxX=w-1; maxY=h-1;
    } else {
      // add small padding
      minX = Math.max(0, minX-6); minY = Math.max(0, minY-6);
      maxX = Math.min(w-1, maxX+6); maxY = Math.min(h-1, maxY+6);
    }
  } else {
    minX=0; minY=0; maxX=w-1; maxY=h-1;
  }

  // scan columns in crop and try to find vertical color runs representing candles
  const cols = [];
  for(let x=minX; x<=maxX; x++){
    // collect non-white pixels length/positions
    let runs = [];
    let inRun=false, runStart=0;
    for(let y=minY;y<=maxY;y++){
      const p = getPixel(x,y);
      // is colored?
      if(p.r<240 || p.g<240 || p.b<240){
        if(!inRun){ inRun=true; runStart=y; }
      } else {
        if(inRun){ runs.push([runStart, y-1]); inRun=false; }
      }
    }
    if(inRun) runs.push([runStart, maxY]);
    // if runs present, keep median run height
    if(runs.length>0){
      // compute run color average (middle pixel)
      const m = Math.floor((runs[0][0] + runs[0][1])/2);
      const p = getPixel(x, m);
      cols.push({x, runs, color:p});
    }
  }

  // group neighboring columns into candle candidates
  const groups = [];
  let current = null;
  for(let i=0;i<cols.length;i++){
    const c = cols[i];
    if(!current){
      current = {cols:[c], x0:c.x, x1:c.x};
    } else {
      if(c.x - current.x1 <= 2){ // adjacent or close
        current.cols.push(c); current.x1 = c.x;
      } else {
        groups.push(current); current = {cols:[c], x0:c.x, x1:c.x};
      }
    }
  }
  if(current) groups.push(current);

  // For each group attempt to infer OHLC by mapping y to price-scale (invert y)
  const candles = [];
  for(const g of groups){
    // compute high/low from runs extremes across all cols in group
    let high = Infinity, low = -Infinity;
    let avgColor = {r:0,g:0,b:0}, cnt=0;
    for(const c of g.cols){
      for(const r of c.runs){
        if(r[0] < high) high = r[0];
        if(r[1] > low) low = r[1];
      }
      avgColor.r += c.color.r; avgColor.g += c.color.g; avgColor.b += c.color.b; cnt++;
    }
    avgColor.r = Math.round(avgColor.r/cnt); avgColor.g = Math.round(avgColor.g/cnt); avgColor.b = Math.round(avgColor.b/cnt);
    // identify body top/bottom by finding larger contiguous colored vertical section in center column
    const midCol = g.cols[Math.floor(g.cols.length/2)];
    // search for top and bottom of main colored block in midCol
    let bodyTop = null, bodyBottom = null;
    for(const r of midCol.runs){
      // choose the run with largest height
      const hRun = r[1]-r[0];
      if(bodyTop===null || hRun > (bodyBottom-bodyTop || -1)){
        bodyTop = r[0]; bodyBottom = r[1];
      }
    }
    // if no body found, use extremes
    if(bodyTop===null){ bodyTop = high; bodyBottom = low; }

    // map pixel Y to normalized price (0..1) inverted (0 bottom,1 top)
    const toPrice = y => {
      // map minY..maxY -> 1..0 (so higher pixel = higher price)
      const rel = (y - minY) / Math.max(1, (maxY - minY));
      return 1 - rel;
    };
    const o = toPrice(bodyBottom), cval = toPrice(bodyTop);
    // open/close sign: use avgColor greenish => close>open (bull), reddish => close<open (bear)
    let isBull = avgColor.g > avgColor.r && avgColor.g > avgColor.b;
    // fallback: compare body midpoint to high/low midpoint
    const bodyMid = (bodyTop + bodyBottom)/2;
    // compute highs/lows normalized
    const hi = toPrice(high), lo = toPrice(low);

    let openPrice, closePrice;
    if(isBull){
      openPrice = o*1.0; closePrice = cval*1.0;
    } else {
      openPrice = cval*1.0; closePrice = o*1.0;
    }

    candles.push({
      x: (g.x0+g.x1)/2,
      open: openPrice, high: hi, low: lo, close: closePrice,
      color: avgColor
    });
  }

  // Normalize and sort by x
  candles.sort((a,b)=>a.x - b.x);
  // now convert normalized to synthetic price scale (map 0..1 -> minPrice..maxPrice)
  // Use 1..100 arbitrary scale for outputs (relative)
  // But keep values as normalized for indicators
  return {candles, crop:{minX,minY,maxX,maxY}};
}

/* ---------- Scoring & decision logic ---------- */
function analyzeSeries(candles){
  // Candles: array of {open,high,low,close} normalized 0..1
  // Convert normalized to synthetic price series of 100..200 to avoid zero divisions
  if(!candles || candles.length < 6) return {error:'No hay suficientes velas detectadas (min 6).'};
  const scaleBase = 1000;
  const close = candles.map(c=> (c.close * scaleBase) );
  const open = candles.map(c=> (c.open * scaleBase) );
  const high = candles.map(c=> (c.high * scaleBase) );
  const low = candles.map(c=> (c.low * scaleBase) );
  // indicators
  const ema8 = ema(close, 8);
  const ema21 = ema(close, 21);
  const rsiArr = rsi(close, 14);
  const atrArr = atr(high, low, close, 14);

  const i = close.length - 1;
  const lastClose = close[i], prevClose = close[i-1] ?? close[i];
  const lastEma8 = ema8[i] ?? ema8.filter(Boolean).slice(-1)[0];
  const lastEma21 = ema21[i] ?? ema21.filter(Boolean).slice(-1)[0];
  const lastRsi = rsiArr[i] ?? rsiArr.filter(Boolean).slice(-1)[0];
  const lastAtr = atrArr[i] ?? atrArr.filter(Boolean).slice(-1)[0] ?? 0;

  // Rule-based scoring components (0..1)
  let score = 0;
  const factors = [];

  // 1) Trend by EMA crossover
  if(lastEma8 && lastEma21){
    if(lastEma8 > lastEma21){
      score += 0.30; factors.push({t:'EMA', desc:'EMA8 por encima EMA21 → tendencia alcista', weight:0.30});
    } else {
      score -= 0.30; factors.push({t:'EMA', desc:'EMA8 por debajo EMA21 → tendencia bajista', weight:-0.30});
    }
  }

  // 2) Momentum by RSI
  if(lastRsi){
    if(lastRsi > 60){ score += 0.18; factors.push({t:'RSI', desc:`RSI alto (${lastRsi.toFixed(1)}) → momentum alcista`, weight:0.18}); }
    else if(lastRsi < 40){ score -= 0.18; factors.push({t:'RSI', desc:`RSI bajo (${lastRsi.toFixed(1)}) → momentum bajista`, weight:-0.18}); }
    else { factors.push({t:'RSI', desc:`RSI neutro (${lastRsi.toFixed(1)})`, weight:0}); }
  }

  // 3) Volatility: if ATR is large relative to price -> uncertainty penalizada
  const relAtr = lastAtr / Math.max(1, lastClose);
  if(relAtr > 0.015){ score -= 0.08; factors.push({t:'ATR', desc:`Alta volatilidad relativa (${(relAtr*100).toFixed(2)}%) → incertidumbre`, weight:-0.08}); }
  else { score += 0.04; factors.push({t:'ATR', desc:'Baja volatilidad relativa → señal más confiable', weight:0.04}); }

  // 4) Recent candle confirmation: last candle direction
  const lastBull = lastClose > prevClose;
  if(lastBull){ score += 0.12; factors.push({t:'Candle', desc:'Última vela alcista → confirmación', weight:0.12}); }
  else { score -= 0.12; factors.push({t:'Candle', desc:'Última vela bajista → confirmación bajista', weight:-0.12}); }

  // 5) Pattern: simple engulfing-ish heuristic (compare last body to previous)
  const lastBody = Math.abs(close[i] - open[i]);
  const prevBody = Math.abs(close[i-1] - open[i-1] || 0.0001);
  if(lastBody > prevBody * 1.2){
    if(lastBull) { score += 0.10; factors.push({t:'Pattern', desc:'Vela expansiva alcista (posible ruptura)', weight:0.10}); }
    else { score -= 0.10; factors.push({t:'Pattern', desc:'Vela expansiva bajista (posible ruptura)', weight:-0.10}); }
  }

  // Bound score to 0..1 mapping: score can be negative; convert to 0..100%
  // First normalize raw range: possible extremes roughly -0.6 .. +0.6; scale accordingly
  const normalized = Math.max(-1, Math.min(1, score));
  const probability = Math.round(((normalized + 1) / 2) * 100); // map -1..1 -> 0..100
  // Recommendation:
  let recommendation = 'NEUTRAL';
  if(probability >= 60) recommendation = 'BUY';
  else if(probability <= 40) recommendation = 'SELL';
  else recommendation = 'NEUTRAL';

  // Construct explanation text from factors plus classical references
  const explanationLines = [];
  explanationLines.push(`Indicadores calculados: EMA8=${(lastEma8||0).toFixed(4)}, EMA21=${(lastEma21||0).toFixed(4)}, RSI=${(lastRsi||0).toFixed(2)}, ATR=${(lastAtr||0).toFixed(4)} (escala relativa).`);
  explanationLines.push(`Se combinaron reglas clásicas: medias móviles (tendencia), RSI (momentum), ATR (volatilidad) y confirmación por vela.`);
  explanationLines.push(`Factores:`);
  for(const f of factors) explanationLines.push(` • ${f.desc} (peso ${f.weight>0?'+':''}${f.weight})`);
  explanationLines.push('');
  explanationLines.push(`Basado en patrones y libros de referencia (p. ej. "Japanese Candlestick Charting Techniques" — Steve Nison; "Technical Analysis of the Financial Markets" — John J. Murphy), la recomendación es: ${recommendation} con probabilidad estimada ${probability}%.`);
  explanationLines.push('');
  explanationLines.push(`Limitaciones: extracción desde imagen = aproximada; mejores resultados con datos OHLC desde API. Use esto como guía, no como ejecución automática.`);

  return {
    probability, recommendation, factors, explanation: explanationLines.join('\\n'),
    indicators:{ema8: lastEma8, ema21: lastEma21, rsi:lastRsi, atr:lastAtr},
    series:{open,high,low,close}
  };
}

/* ---------- UI wiring and process ---------- */
document.getElementById('startBtn').addEventListener('click', async ()=>{
  if(!loadedImage) return alert('Subí una imagen primero.');
  document.getElementById('status').innerHTML = 'Estado: <span class="badge">Analizando imagen</span>';
  document.getElementById('resultBox').style.display='none';
  // draw current image (in case)
  ctx.drawImage(loadedImage, 0,0, canvas.width, canvas.height);

  const opts = {
    autoCrop: document.getElementById('autoCrop').checked
  };
  const extraction = extractCandlesFromCanvas(opts);
  if(!extraction || !extraction.candles || extraction.candles.length < 6){
    document.getElementById('status').innerHTML = 'Estado: <span class="badge">Error: no se detectaron suficientes velas en la imagen</span>';
    return;
  }
  extractedCandles = extraction;

  // show a 20-second countdown (or shorter if many candles small)
  const analysisTime = 20; // seconds
  let t = analysisTime;
  const cd = document.getElementById('countdown');
  cd.textContent = `Análisis en progreso: ${t}s`;
  const timer = setInterval(()=>{
    t--; cd.textContent = `Análisis en progreso: ${t}s`;
    if(t<=0){ clearInterval(timer); cd.textContent = 'Análisis completado.'; finalizeAnalysis(); }
  }, 1000);

  // visual: highlight crop
  if(opts.autoCrop){
    const c = extraction.crop;
    ctx.strokeStyle = '#0f6fff';
    ctx.lineWidth = 2;
    ctx.strokeRect(c.minX, c.minY, c.maxX-c.minX, c.maxY-c.minY);
  }

  // allow user to stop? For simplicity, we wait.
});

function finalizeAnalysis(){
  // analyze extractedCandles
  const result = analyzeSeries(extractedCandles.candles);
  if(result.error){
    document.getElementById('status').innerHTML = 'Estado: <span class="badge">Error al analizar</span>';
    alert(result.error);
    return;
  }
  // update UI
  document.getElementById('resultBox').style.display='block';
  const recText = document.getElementById('recText');
  recText.textContent = result.recommendation;
  recText.className = (result.recommendation==='BUY'?'green': result.recommendation==='SELL'?'red':'gray');
  document.getElementById('probText').textContent = result.probability + '%';
  document.getElementById('meterBar').style.width = result.probability + '%';
  // factors
  const list = document.getElementById('factors'); list.innerHTML = '';
  for(const f of result.factors){
    const li = document.createElement('li'); li.textContent = f.desc; list.appendChild(li);
  }
  // explanation
  document.getElementById('explanation').textContent = result.explanation;
  // data out
  const pretty = extractedCandles.candles.map((c,idx)=> `#${idx+1} O:${c.open.toFixed(4)} H:${c.high.toFixed(4)} L:${c.low.toFixed(4)} C:${c.close.toFixed(4)}`).join('\\n');
  document.getElementById('dataOut').textContent = pretty;
  document.getElementById('status').innerHTML = 'Estado: <span class="badge">Análisis finalizado</span>';
}

/* End of script */
</script>
</body>
</html>
